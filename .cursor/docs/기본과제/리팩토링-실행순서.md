# Basic 폴더 리팩토링 실행 순서

이 문서는 `src/basic` 폴더를 `src/origin`을 참고하여 리팩토링하는 구체적인 실행 순서를 안내합니다.

---

## 📋 리팩토링 전체 흐름

```
1단계: Constants 분리 ✅ (완료)
    ↓
2단계: Models 계층 구현 (순수함수)
    ↓
3단계: Hooks 계층 구현 (비즈니스 로직)
    ↓
4단계: Components 계층 구현 (UI)
    ↓
5단계: App.tsx 리팩토링 (통합)
    ↓
6단계: 테스트 및 검증
```

---

## ✅ 1단계: Constants 분리 (완료)

### 목표
- 모든 상수를 `constants/index.ts`로 분리
- 단일 진실 공급원(Single Source of Truth) 구현

### 완료된 작업
- ✅ `initialProducts`, `initialCoupons` 정의
- ✅ UI 상수 (`DEBOUNCE_DELAY`, `NOTIFICATION_DURATION`) 정의
- ✅ 비즈니스 규칙 상수 정의
- ✅ 유효성 검사 상수 정의
- ✅ `App.tsx`에서 하드코딩된 값들을 상수로 교체

### 참고 파일
- `src/basic/constants/index.ts`
- `src/basic/App.tsx` (상수 import 부분)

---

## 🔨 2단계: Models 계층 구현 (순수함수)

### 목표
- 엔티티 관련 계산 로직을 순수함수로 분리
- `models/` 폴더에 엔티티별 순수함수 구현

### 실행 순서

#### 2.1 `models/cart.ts` 구현

**참고 파일**: `src/origin/App.tsx`의 다음 함수들
- `getMaxApplicableDiscount`
- `calculateItemTotal`
- `calculateCartTotal`
- `getRemainingStock`
- `addItemToCart` (순수함수 버전)
- `removeItemFromCart` (순수함수 버전)
- `updateCartItemQuantity` (순수함수 버전)

**구현 예시**:

```typescript
// models/cart.ts
import { CartItem, Product, Coupon } from '../../types';
import {
  BULK_PURCHASE_QUANTITY,
  BULK_PURCHASE_ADDITIONAL_DISCOUNT,
  MAX_DISCOUNT_RATE
} from '../constants';

/**
 * 적용 가능한 최대 할인율 계산
 * @param item 장바구니 아이템
 * @param cart 전체 장바구니
 * @returns 최대 할인율 (0 ~ 1)
 */
export const getMaxApplicableDiscount = (
  item: CartItem,
  cart: CartItem[]
): number => {
  const { discounts } = item.product;
  const { quantity } = item;
  
  // 기본 할인율 계산
  const baseDiscount = discounts.reduce((maxDiscount, discount) => {
    return quantity >= discount.quantity && discount.rate > maxDiscount 
      ? discount.rate 
      : maxDiscount;
  }, 0);
  
  // 대량 구매 추가 할인
  const hasBulkPurchase = cart.some(
    cartItem => cartItem.quantity >= BULK_PURCHASE_QUANTITY
  );
  if (hasBulkPurchase) {
    return Math.min(
      baseDiscount + BULK_PURCHASE_ADDITIONAL_DISCOUNT,
      MAX_DISCOUNT_RATE
    );
  }
  
  return baseDiscount;
};

/**
 * 개별 아이템의 할인 적용 후 총액 계산
 */
export const calculateItemTotal = (item: CartItem, cart: CartItem[]): number => {
  const { price } = item.product;
  const { quantity } = item;
  const discount = getMaxApplicableDiscount(item, cart);
  
  return Math.round(price * quantity * (1 - discount));
};

/**
 * 장바구니 총액 계산 (할인 전/후)
 */
export const calculateCartTotal = (
  cart: CartItem[],
  selectedCoupon: Coupon | null
): {
  totalBeforeDiscount: number;
  totalAfterDiscount: number;
} => {
  let totalBeforeDiscount = 0;
  let totalAfterDiscount = 0;

  cart.forEach(item => {
    const itemPrice = item.product.price * item.quantity;
    totalBeforeDiscount += itemPrice;
    totalAfterDiscount += calculateItemTotal(item, cart);
  });

  // 쿠폰 적용
  if (selectedCoupon) {
    if (selectedCoupon.discountType === 'amount') {
      totalAfterDiscount = Math.max(0, totalAfterDiscount - selectedCoupon.discountValue);
    } else {
      totalAfterDiscount = Math.round(
        totalAfterDiscount * (1 - selectedCoupon.discountValue / 100)
      );
    }
  }

  return {
    totalBeforeDiscount: Math.round(totalBeforeDiscount),
    totalAfterDiscount: Math.round(totalAfterDiscount)
  };
};

/**
 * 남은 재고 계산
 */
export const getRemainingStock = (
  product: Product,
  cart: CartItem[]
): number => {
  const cartItem = cart.find(item => item.product.id === product.id);
  const remaining = product.stock - (cartItem?.quantity || 0);
  return remaining;
};

/**
 * 장바구니에 상품 추가 (순수함수)
 */
export const addItemToCart = (
  cart: CartItem[],
  product: Product
): CartItem[] => {
  const existingItem = cart.find(item => item.product.id === product.id);
  
  if (existingItem) {
    return cart.map(item =>
      item.product.id === product.id
        ? { ...item, quantity: item.quantity + 1 }
        : item
    );
  }
  
  return [...cart, { product, quantity: 1 }];
};

/**
 * 장바구니에서 상품 제거 (순수함수)
 */
export const removeItemFromCart = (
  cart: CartItem[],
  productId: string
): CartItem[] => {
  return cart.filter(item => item.product.id !== productId);
};

/**
 * 장바구니 아이템 수량 변경 (순수함수)
 */
export const updateCartItemQuantity = (
  cart: CartItem[],
  productId: string,
  quantity: number
): CartItem[] => {
  if (quantity <= 0) {
    return removeItemFromCart(cart, productId);
  }
  
  return cart.map(item =>
    item.product.id === productId
      ? { ...item, quantity }
      : item
  );
};
```

**체크리스트**:
- [ ] 모든 함수가 순수함수인가? (외부 상태에 의존하지 않음)
- [ ] 모든 필요한 데이터가 파라미터로 전달되는가?
- [ ] constants에서 비즈니스 규칙을 가져오는가?
- [ ] 불변성을 유지하는가? (새 배열/객체 반환)

#### 2.2 `models/product.ts` 구현 (필요시)

**참고 파일**: `src/origin/App.tsx`의 상품 관련 함수들

**구현할 함수들** (필요한 경우):
- `getProductById`
- `filterProducts`
- `validateProductStock`

#### 2.3 `models/coupon.ts` 구현 (필요시)

**참고 파일**: `src/origin/App.tsx`의 쿠폰 관련 함수들

**구현할 함수들** (필요한 경우):
- `validateCoupon`
- `applyCouponToTotal`

---

## 🎣 3단계: Hooks 계층 구현 (비즈니스 로직)

### 목표
- Component에서 비즈니스 로직을 Hook으로 분리
- 각 Hook이 단일 책임을 가지도록 설계

### 실행 순서

#### 3.1 `hooks/useCart.ts` 구현

**참고 파일**: `src/origin/App.tsx`의 장바구니 관련 로직

**구현해야 할 것들**:

```typescript
// hooks/useCart.ts
import { useState, useCallback, useMemo, useEffect } from 'react';
import { CartItem, Coupon, Product } from '../../types';
import {
  calculateCartTotal,
  getRemainingStock,
  addItemToCart,
  removeItemFromCart,
  updateCartItemQuantity
} from '../models/cart';
import { MIN_ORDER_AMOUNT_FOR_PERCENTAGE_COUPON } from '../constants';

export const useCart = () => {
  // 상태 관리
  const [cart, setCart] = useState<CartItem[]>(() => {
    const saved = localStorage.getItem('cart');
    if (saved) {
      try {
        return JSON.parse(saved);
      } catch {
        return [];
      }
    }
    return [];
  });

  const [selectedCoupon, setSelectedCoupon] = useState<Coupon | null>(null);

  // localStorage 동기화
  useEffect(() => {
    if (cart.length > 0) {
      localStorage.setItem('cart', JSON.stringify(cart));
    } else {
      localStorage.removeItem('cart');
    }
  }, [cart]);

  // 액션: 장바구니에 상품 추가
  const addToCart = useCallback((product: Product) => {
    const remainingStock = getRemainingStock(product, cart);
    if (remainingStock <= 0) {
      return { success: false, message: '재고가 부족합니다!' };
    }

    setCart(prevCart => {
      const existingItem = prevCart.find(item => item.product.id === product.id);
      
      if (existingItem) {
        const newQuantity = existingItem.quantity + 1;
        if (newQuantity > product.stock) {
          return prevCart; // 재고 초과
        }
        return updateCartItemQuantity(prevCart, product.id, newQuantity);
      }
      
      return addItemToCart(prevCart, product);
    });

    return { success: true, message: '장바구니에 담았습니다' };
  }, [cart]);

  // 액션: 장바구니에서 상품 제거
  const removeFromCart = useCallback((productId: string) => {
    setCart(prevCart => removeItemFromCart(prevCart, productId));
  }, []);

  // 액션: 수량 변경
  const updateQuantity = useCallback((productId: string, quantity: number) => {
    setCart(prevCart => updateCartItemQuantity(prevCart, productId, quantity));
  }, []);

  // 액션: 쿠폰 적용
  const applyCoupon = useCallback((coupon: Coupon) => {
    const { totalAfterDiscount } = calculateCartTotal(cart, coupon);
    
    if (totalAfterDiscount < MIN_ORDER_AMOUNT_FOR_PERCENTAGE_COUPON && 
        coupon.discountType === 'percentage') {
      return { 
        success: false, 
        message: `percentage 쿠폰은 ${MIN_ORDER_AMOUNT_FOR_PERCENTAGE_COUPON.toLocaleString()}원 이상 구매 시 사용 가능합니다.` 
      };
    }

    setSelectedCoupon(coupon);
    return { success: true, message: '쿠폰이 적용되었습니다.' };
  }, [cart]);

  // 계산: 총액
  const total = useMemo(() => {
    return calculateCartTotal(cart, selectedCoupon);
  }, [cart, selectedCoupon]);

  // 계산: 총 아이템 수
  const totalItemCount = useMemo(() => {
    return cart.reduce((sum, item) => sum + item.quantity, 0);
  }, [cart]);

  // 계산: 남은 재고
  const getRemainingStockForProduct = useCallback((product: Product) => {
    return getRemainingStock(product, cart);
  }, [cart]);

  return {
    // 상태
    cart,
    selectedCoupon,
    
    // 계산된 값
    total,
    totalItemCount,
    
    // 액션
    addToCart,
    removeFromCart,
    updateQuantity,
    applyCoupon,
    setSelectedCoupon,
    getRemainingStockForProduct,
    
    // 유틸리티
    clearCart: () => setCart([])
  };
};
```

**체크리스트**:
- [ ] 상태 관리가 올바르게 구현되었는가?
- [ ] localStorage 동기화가 구현되었는가?
- [ ] 모든 액션이 useCallback으로 메모이제이션되었는가?
- [ ] 계산된 값들이 useMemo로 메모이제이션되었는가?
- [ ] models의 순수함수를 사용하는가?

#### 3.2 `hooks/useProducts.ts` 구현

**참고 파일**: `src/origin/App.tsx`의 상품 관련 로직

**구현해야 할 것들**:
- 상품 목록 상태 관리
- localStorage 동기화
- 상품 CRUD 작업
- 재고 업데이트
- 할인 규칙 추가/삭제

**체크리스트**:
- [ ] 상품 목록 상태 관리
- [ ] localStorage 동기화
- [ ] 상품 추가/수정/삭제 함수
- [ ] 재고 업데이트 함수
- [ ] 할인 규칙 관리 함수

#### 3.3 `hooks/useCoupons.ts` 구현

**참고 파일**: `src/origin/App.tsx`의 쿠폰 관련 로직

**구현해야 할 것들**:
- 쿠폰 목록 상태 관리
- localStorage 동기화
- 쿠폰 추가/삭제 함수

**체크리스트**:
- [ ] 쿠폰 목록 상태 관리
- [ ] localStorage 동기화
- [ ] 쿠폰 추가/삭제 함수

#### 3.4 `hooks/useDebounce.ts` 구현 (선택사항)

**구현 예시**:

```typescript
// hooks/useDebounce.ts
import { useState, useEffect } from 'react';
import { DEBOUNCE_DELAY } from '../constants';

export const useDebounce = <T,>(value: T, delay: number = DEBOUNCE_DELAY): T => {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(timer);
  }, [value, delay]);

  return debouncedValue;
};
```

---

## 🎨 4단계: Components 계층 구현 (UI)

### 목표
- 엔티티를 다루는 컴포넌트와 UI 컴포넌트 분리
- 프레젠테이션 컴포넌트와 컨테이너 컴포넌트 구분

### 실행 순서

#### 4.1 UI 컴포넌트 구현

**`components/ui/Button.tsx`**:

```typescript
// components/ui/Button.tsx
interface ButtonProps {
  children: React.ReactNode;
  onClick?: () => void;
  disabled?: boolean;
  variant?: 'primary' | 'secondary' | 'danger';
  className?: string;
}

export const Button = ({ 
  children, 
  onClick, 
  disabled,
  variant = 'primary',
  className = ''
}: ButtonProps) => {
  const baseStyles = 'px-4 py-2 rounded-md font-medium transition-colors';
  const variantStyles = {
    primary: 'bg-blue-500 text-white hover:bg-blue-600',
    secondary: 'bg-gray-200 text-gray-800 hover:bg-gray-300',
    danger: 'bg-red-500 text-white hover:bg-red-600'
  };

  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={`${baseStyles} ${variantStyles[variant]} ${className} ${
        disabled ? 'opacity-50 cursor-not-allowed' : ''
      }`}
    >
      {children}
    </button>
  );
};
```

**`components/ui/Input.tsx`**:

```typescript
// components/ui/Input.tsx
interface InputProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  type?: string;
  className?: string;
}

export const Input = ({
  value,
  onChange,
  placeholder,
  type = 'text',
  className = ''
}: InputProps) => {
  return (
    <input
      type={type}
      value={value}
      onChange={(e) => onChange(e.target.value)}
      placeholder={placeholder}
      className={`w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500 ${className}`}
    />
  );
};
```

**체크리스트**:
- [ ] UI 컴포넌트가 엔티티를 모르는가? (범용 컴포넌트)
- [ ] 재사용 가능한가?

#### 4.2 엔티티 컴포넌트 구현

**`components/ProductCard.tsx`**:

```typescript
// components/ProductCard.tsx
import { Product } from '../../types';
import { Button } from './ui/Button';

interface ProductCardProps {
  product: Product;
  remainingStock: number;
  onAddToCart: (product: Product) => void;
}

export const ProductCard = ({ 
  product, 
  remainingStock, 
  onAddToCart 
}: ProductCardProps) => {
  const isOutOfStock = remainingStock <= 0;

  return (
    <div className="border rounded-lg p-4">
      <h3 className="text-lg font-semibold">{product.name}</h3>
      <p className="text-gray-600">{product.price.toLocaleString()}원</p>
      <p className="text-sm text-gray-500">재고: {remainingStock}개</p>
      <Button
        onClick={() => onAddToCart(product)}
        disabled={isOutOfStock}
        variant={isOutOfStock ? 'secondary' : 'primary'}
      >
        {isOutOfStock ? '품절' : '장바구니 담기'}
      </Button>
    </div>
  );
};
```

**`components/CartItemView.tsx`**:

```typescript
// components/CartItemView.tsx
import { CartItem } from '../../types';
import { Button } from './ui/Button';

interface CartItemViewProps {
  item: CartItem;
  onRemove: () => void;
  onUpdateQuantity: (quantity: number) => void;
}

export const CartItemView = ({
  item,
  onRemove,
  onUpdateQuantity
}: CartItemViewProps) => {
  return (
    <div className="flex items-center justify-between border-b py-4">
      <div>
        <h4 className="font-semibold">{item.product.name}</h4>
        <p className="text-gray-600">
          {item.product.price.toLocaleString()}원 × {item.quantity}
        </p>
      </div>
      <div className="flex items-center gap-2">
        <button
          onClick={() => onUpdateQuantity(item.quantity - 1)}
          className="px-2 py-1 border rounded"
        >
          -
        </button>
        <span>{item.quantity}</span>
        <button
          onClick={() => onUpdateQuantity(item.quantity + 1)}
          className="px-2 py-1 border rounded"
        >
          +
        </button>
        <Button onClick={onRemove} variant="danger" className="ml-2">
          삭제
        </Button>
      </div>
    </div>
  );
};
```

**체크리스트**:
- [ ] 엔티티 컴포넌트가 엔티티 타입을 props로 받는가?
- [ ] UI 컴포넌트를 재사용하는가?

#### 4.3 컨테이너 컴포넌트 구현

**`components/CartPage.tsx`**:

```typescript
// components/CartPage.tsx
import { useCart } from '../hooks/useCart';
import { useProducts } from '../hooks/useProducts';
import { useCoupons } from '../hooks/useCoupons';
import { ProductCard } from './ProductCard';
import { CartItemView } from './CartItemView';
import { Input } from './ui/Input';
import { Button } from './ui/Button';
import { useDebounce } from '../hooks/useDebounce';

export const CartPage = () => {
  const { cart, total, addToCart, removeFromCart, updateQuantity } = useCart();
  const { products, getRemainingStockForProduct } = useProducts();
  const { coupons, applyCoupon } = useCoupons();
  
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm);

  const filteredProducts = products.filter(product =>
    product.name.includes(debouncedSearchTerm)
  );

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">쇼핑몰</h1>
      
      {/* 검색 */}
      <Input
        value={searchTerm}
        onChange={setSearchTerm}
        placeholder="상품 검색..."
      />

      {/* 상품 목록 */}
      <div className="grid grid-cols-3 gap-4 my-4">
        {filteredProducts.map(product => (
          <ProductCard
            key={product.id}
            product={product}
            remainingStock={getRemainingStockForProduct(product)}
            onAddToCart={addToCart}
          />
        ))}
      </div>

      {/* 장바구니 */}
      <div className="border rounded-lg p-4">
        <h2 className="text-xl font-bold mb-4">장바구니</h2>
        {cart.map(item => (
          <CartItemView
            key={item.product.id}
            item={item}
            onRemove={() => removeFromCart(item.product.id)}
            onUpdateQuantity={(qty) => updateQuantity(item.product.id, qty)}
          />
        ))}
        <div className="mt-4">
          <p className="text-lg font-semibold">
            총액: {total.totalAfterDiscount.toLocaleString()}원
          </p>
        </div>
      </div>
    </div>
  );
};
```

**`components/AdminPage.tsx`**:

```typescript
// components/AdminPage.tsx
import { useProducts } from '../hooks/useProducts';
import { useCoupons } from '../hooks/useCoupons';
// ... 관리자 페이지 구현
```

**체크리스트**:
- [ ] 컨테이너 컴포넌트가 Hook을 사용하는가?
- [ ] 엔티티 컴포넌트와 UI 컴포넌트를 조합하는가?
- [ ] 비즈니스 로직이 컴포넌트에 없는가?

---

## 🔄 5단계: App.tsx 리팩토링 (통합)

### 목표
- 거대한 `App.tsx`를 간단한 라우팅 컴포넌트로 변경
- 분리된 컴포넌트와 Hook을 사용

### 실행 순서

#### 5.1 App.tsx 간소화

**Before (현재)**:
```typescript
// App.tsx - 1000줄 이상의 거대한 컴포넌트
const App = () => {
  // 모든 상태
  // 모든 로직
  // 모든 UI
};
```

**After (목표)**:
```typescript
// App.tsx
import { useState } from 'react';
import { CartPage } from './components/CartPage';
import { AdminPage } from './components/AdminPage';

const App = () => {
  const [isAdmin, setIsAdmin] = useState(false);

  return (
    <div className="min-h-screen bg-gray-50">
      {/* 네비게이션 */}
      <nav className="bg-white shadow">
        <div className="container mx-auto px-4 py-4 flex justify-between items-center">
          <h1 className="text-xl font-bold">쇼핑몰</h1>
          <button
            onClick={() => setIsAdmin(!isAdmin)}
            className="px-4 py-2 bg-blue-500 text-white rounded"
          >
            {isAdmin ? '고객 모드' : '관리자 모드'}
          </button>
        </div>
      </nav>

      {/* 메인 컨텐츠 */}
      <main>
        {isAdmin ? <AdminPage /> : <CartPage />}
      </main>
    </div>
  );
};

export default App;
```

**체크리스트**:
- [ ] App.tsx가 100줄 이하로 줄어들었는가?
- [ ] 모든 비즈니스 로직이 Hook으로 분리되었는가?
- [ ] 모든 UI가 컴포넌트로 분리되었는가?
- [ ] App.tsx는 라우팅/모드 전환만 담당하는가?

---

## ✅ 6단계: 테스트 및 검증

### 목표
- 리팩토링 전후 동작이 동일한지 확인
- 테스트 통과 확인

### 실행 순서

#### 6.1 기능 테스트

**체크리스트**:
- [ ] 상품 목록이 정상적으로 표시되는가?
- [ ] 상품 검색이 작동하는가?
- [ ] 장바구니에 상품 추가가 작동하는가?
- [ ] 장바구니에서 상품 제거가 작동하는가?
- [ ] 수량 변경이 작동하는가?
- [ ] 쿠폰 적용이 작동하는가?
- [ ] 총액 계산이 정확한가?
- [ ] 할인 계산이 정확한가?
- [ ] localStorage 동기화가 작동하는가?
- [ ] 관리자 모드가 작동하는가?

#### 6.2 테스트 실행

```bash
# 테스트 실행
pnpm test

# 또는 특정 테스트만 실행
pnpm test:basic
```

#### 6.3 수동 테스트

1. 브라우저에서 `pnpm dev:basic` 실행
2. 모든 기능을 직접 테스트
3. 콘솔 에러 확인

---

## 📊 리팩토링 진행 상황 체크리스트

### 전체 진행 상황

- [x] **1단계: Constants 분리** (완료)
- [ ] **2단계: Models 계층 구현**
  - [ ] `models/cart.ts` 구현
  - [ ] `models/product.ts` 구현 (필요시)
  - [ ] `models/coupon.ts` 구현 (필요시)
- [ ] **3단계: Hooks 계층 구현**
  - [ ] `hooks/useCart.ts` 구현
  - [ ] `hooks/useProducts.ts` 구현
  - [ ] `hooks/useCoupons.ts` 구현
  - [ ] `hooks/useDebounce.ts` 구현 (선택사항)
- [ ] **4단계: Components 계층 구현**
  - [ ] UI 컴포넌트 구현 (`Button`, `Input` 등)
  - [ ] 엔티티 컴포넌트 구현 (`ProductCard`, `CartItemView` 등)
  - [ ] 컨테이너 컴포넌트 구현 (`CartPage`, `AdminPage`)
- [ ] **5단계: App.tsx 리팩토링**
  - [ ] App.tsx 간소화
  - [ ] 분리된 컴포넌트 통합
- [ ] **6단계: 테스트 및 검증**
  - [ ] 기능 테스트
  - [ ] 테스트 실행
  - [ ] 수동 테스트

---

## 🎯 각 단계별 완료 기준

### 2단계 완료 기준
- [ ] 모든 계산 함수가 순수함수로 작성됨
- [ ] 함수가 외부 상태에 의존하지 않음
- [ ] constants에서 비즈니스 규칙을 가져옴
- [ ] 불변성을 유지함

### 3단계 완료 기준
- [ ] 모든 비즈니스 로직이 Hook으로 분리됨
- [ ] 각 Hook이 단일 책임을 가짐
- [ ] Hook 간 의존성이 최소화됨
- [ ] models의 순수함수를 사용함

### 4단계 완료 기준
- [ ] 엔티티 컴포넌트와 UI 컴포넌트가 분리됨
- [ ] 컨테이너 컴포넌트가 Hook을 사용함
- [ ] 컴포넌트의 재사용성이 향상됨

### 5단계 완료 기준
- [ ] App.tsx가 100줄 이하로 줄어듦
- [ ] App.tsx는 라우팅/모드 전환만 담당
- [ ] 모든 기능이 정상 작동함

---

## 💡 리팩토링 팁

1. **작은 단계로 진행**: 한 번에 모든 것을 바꾸지 말고 단계별로 진행
2. **테스트 먼저**: 각 단계마다 기능이 정상 작동하는지 확인
3. **origin 참고**: 막힐 때는 `src/origin/App.tsx`를 참고
4. **커밋 자주**: 각 단계 완료 시 커밋
5. **에러 확인**: TypeScript 에러와 린터 에러를 수시로 확인

---

## 📚 참고 문서

- `.cursor/docs/학습방법.md`: 상세한 개념 설명
- `.cursor/docs/지식맵.md`: 사전 지식과 학습 성과
- `src/origin/App.tsx`: 원본 코드 참고

---

**마지막 업데이트**: 2025-12-01

